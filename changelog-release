#!/usr/bin/env python3

import argparse
import datetime
import collections
import glob
import os
import os.path as p
import re
import subprocess


class Release(collections.namedtuple('Release', ['year', 'num'])):
    """ChangeLog infrastructure for a specific release."""

    @property
    def id(self):
        """Release ID without leading 'r'."""
        return '{}_{:03n}'.format(self.year, self.num)

    @property
    def filename(self):
        """Where the ChangeLog for this release resides."""
        return 'src/reference/changes/{}/r{:03n}.rst'.format(
            self.year, self.num)

    def read_changelog(self):
        """Returns ChangeLog contents."""
        with open(self.filename, 'r') as f:
            return f.read()

    def write_changelog(self, string):
        """Replaces ChangeLog with `string`."""
        with open(self.filename, 'w') as f:
            f.write(string)


def last_release():
    candidates = glob.glob('src/reference/changes/{}/r*.rst'.format(
        datetime.date.today().year))
    candidates.sort()
    try:
        last = candidates[-1]
    except IndexError:
        raise RuntimeError('cannot handle new year yet -- edit manually')
    last = p.basename(last).split('.')[0].lstrip('r')
    last = int(last, 10)
    return Release(datetime.date.today().year, last)


def finalize_old_changelog(last_release, release_date):
    text = last_release.read_changelog()

    r_publish_date = re.compile(
        r'^\.\. XXX update on release :Publish Date: YYYY-MM-DD')
    text = r_publish_date.sub(':Publish Date: {}'.format(release_date), text)

    r_headline = re.compile(r'(Release ...._...) \(unreleased\)\n-{6,40}')
    text = r_headline.sub(r'\1 ({})\n-----------------------------'.format(
        release_date), text)

    r_empty_sec = re.compile(r'^.{6,40}\n\^{6,40}\n+^\* nothing yet\n+', re.M)
    text = r_empty_sec.sub('', text, count=4)
    last_release.write_changelog(text)


def prepare_new_changelog(new_release):
    print('Preparing release {}'.format(new_release.id))
    with open('src/reference/changes/skel') as f:
        changes = f.read()
    changes = changes.replace('YYYY_NNN', new_release.id)
    new_release.write_changelog(changes)
    subprocess.check_call(['git', 'add', new_release.filename])
    try:
        os.unlink('CHANGES.rst')
    except FileNotFoundError:
        pass
    os.symlink(new_release.filename, 'CHANGES.rst')


def update_index(last, new):
    year = datetime.date.today().year
    releases = [
        e.name for e in os.scandir(p.join('src/reference/changes', str(year)))
        if e.is_file() and re.match(r"^r\d+\.rst$", e.name)
    ]
    with open('src/reference/changes/{}/index.rst'.format(year), 'w') as index:
        print("""\
{year}
====

Releases performed in {year}.

.. toctree::
   :maxdepth: 1

""".format(year=year), file=index)
        for r in sorted(releases):
            print('   ' + r.replace('.rst', ''), file=index)


def main():
    a = argparse.ArgumentParser()
    default_release_date = datetime.date.today() + datetime.timedelta(days=1)
    a.add_argument('release_date', nargs='?',
                   default=default_release_date.strftime('%Y-%m-%d'),
                   help='set planned roll-out date (default: %(default)s)')
    args = a.parse_args()
    if not re.match(r'\d{4}-\d{2}-\d{2}$', args.release_date):
        a.error("Release date must be formatted as YYYY-MM-DD")
    last = last_release()
    new = Release(datetime.date.today().year, last.num + 1)
    finalize_old_changelog(last, args.release_date)
    prepare_new_changelog(new)
    update_index(last, new)
    print('Committing changes')
    subprocess.check_call([
        'git', 'commit', '-am', 'finalize changelog r{}, create r{}'.format(
            last.id, new.id)])


if __name__ == '__main__':
    main()
